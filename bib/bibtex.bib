
@misc{ibm_anatomy_flawed_microbenchmark,
	title = {Anatomy of a flawed microbenchmark},
	copyright = {© Copyright IBM Corporation 2005},
	url = {http://www.ibm.com/developerworks/library/j-jtp02225/index.html},
	abstract = {Software engineers are notoriously obsessed, sometimes excessively, with performance. While sometimes performance is the most important requirement in a software project, as it might be when developing protocol routing software for a high-speed switch, most of the time performance needs to be balanced against other requirements, such as functionality, reliability, maintainability, extensibility, time to market, and other business and engineering considerations. In this month's Java theory and practice, columnist Brian Goetz explores why it is so much harder to measure the performance of Java language constructs than it looks.},
	language = {en},
	urldate = {2019-04-03},
	year = {2005},
	file = {Snapshot:/home/niklas/Zotero/storage/TUYQQ69A/j-jtp02225.html:text/html}
}

@misc{oracle_avoiding_benchmarking_pitfalls,
	title = {Avoiding {Benchmarking} {Pitfalls} on the {JVM}},
	url = {https://www.oracle.com/technetwork/articles/java/architect-benchmarking-2266277.html},
	urldate = {2019-04-03},
	file = {Avoiding Benchmarking Pitfalls on the JVM:/home/niklas/Zotero/storage/DVPEGW3P/architect-benchmarking-2266277.html:text/html}
}

@misc{wiki_openjdk_hotspot_performance_techniques,
	title = {{PerformanceTechniques} - {HotSpot} - {OpenJDK} {Wiki}},
	url = {https://wiki.openjdk.java.net/display/HotSpot/PerformanceTechniques},
	urldate = {2019-04-03},
	file = {PerformanceTechniques - HotSpot - OpenJDK Wiki:/home/niklas/Zotero/storage/SIJPC5DQ/PerformanceTechniques.html:text/html}
}

@misc{criterion,
	title = {A criterion tutorial},
	url = {http://www.serpentine.com/criterion/tutorial.html},
	urldate = {2019-04-04},
	file = {A criterion tutorial:/home/niklas/Zotero/storage/AMUZCT95/tutorial.html:text/html}
}

@misc{quora_pros_and_cons_compiled_languages,
	title = {What are the pros and cons of a compiled programming language compared to a non-compiled one? - {Quora}},
	url = {https://www.quora.com/What-are-the-pros-and-cons-of-a-compiled-programming-language-compared-to-a-non-compiled-one#},
	urldate = {2019-04-05},
	file = {What are the pros and cons of a compiled programming language compared to a non-compiled one? - Quora:/home/niklas/Zotero/storage/B9PJ5WND/What-are-the-pros-and-cons-of-a-compiled-programming-language-compared-to-a-non-compiled-one.html:text/html}
}

@article{arxiv_comparative_study_of_languages,
	title = {Comparative study of the {Pros} and {Cons} of {Programming} languages {Java}, {Scala}, {C}++, {Haskell}, {VB} .{NET}, {AspectJ}, {Perl}, {Ruby}, {PHP} \& {Scheme} - a {Team} 11 {COMP}6411-{S}10 {Term} {Report}},
	url = {http://arxiv.org/abs/1008.3431},
	abstract = {With the advent of numerous languages it is difficult to realize the edge of one language in a particular scope over another one. We are making an effort, realizing these few issues and comparing some main stream languages like Java, Scala, C++, Haskell, VB .NET, AspectJ, Perl, Ruby, PHP and Scheme keeping in mind some core issues in program development.},
	urldate = {2019-04-05},
	journal = {arXiv:1008.3431 [cs]},
	author = {Dwarampudi, Venkatreddy and Dhillon, Shahbaz Singh and Shah, Jivitesh and Sebastian, Nikhil Joseph and Kanigicharla, Nitin},
	year = {2010},
	note = {arXiv: 1008.3431},
	keywords = {Computer Science - Programming Languages, D.3},
	annote = {Comment: 28 pages, 2 tables},
	file = {arXiv\:1008.3431 PDF:/home/niklas/Zotero/storage/KQTRDHHM/Dwarampudi et al. - 2010 - Comparative study of the Pros and Cons of Programm.pdf:application/pdf;arXiv.org Snapshot:/home/niklas/Zotero/storage/3IBBMXBJ/1008.html:text/html}
}

@misc{wikipedia_list_programming_languages,
	title = {List of programming languages by type},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=List_of_programming_languages_by_type&oldid=889388419},
	abstract = {This is a list of notable programming languages, grouped by type.
Since there is no overarching classification scheme for programming languages, in many cases, a language will be listed under multiple headings.},
	language = {en},
	urldate = {2019-04-05},
	journal = {Wikipedia},
	year = {2019},
	note = {Page Version ID: 889388419},
	file = {Snapshot:/home/niklas/Zotero/storage/G3ZMS2PY/index.html:text/html}
}

@misc{stackoverflow_pros_and_cons_interpreted_languages,
	title = {Pros {And} {Cons} {Of} {Interpreted} {Languages}},
	url = {https://stackoverflow.com/questions/1610539/pros-and-cons-of-interpreted-languages},
	urldate = {2019-04-05},
	journal = {Stack Overflow},
	file = {Snapshot:/home/niklas/Zotero/storage/I8FH3QF3/pros-and-cons-of-interpreted-languages.html:text/html}
}

@inproceedings{haskell_lazy_with_class,
	address = {San Diego, California},
	title = {A history of {Haskell}: being lazy with class},
	shorttitle = {A history of {Haskell}},
	url = {http://portal.acm.org/citation.cfm?doid=1238844.1238856},
	doi = {10.1145/1238844.1238856},
	abstract = {This paper describes the history of Haskell, including its genesis and principles, technical contributions, implementations and tools, and applications and impact.},
	language = {en},
	urldate = {2019-04-05},
	booktitle = {Proceedings of the third {ACM} {SIGPLAN} conference on {History} of programming languages  - {HOPL} {III}},
	publisher = {ACM Press},
	author = {Hudak, Paul and Hughes, John and Jones, Simon Peyton and Wadler, Philip},
	year = {2007},
	pages = {12--1--12--55},
	file = {Hudak et al. - 2007 - A history of Haskell being lazy with class.pdf:/home/niklas/Zotero/storage/CSMVLV6L/Hudak et al. - 2007 - A history of Haskell being lazy with class.pdf:application/pdf}
}

@misc{haskell_compiler_structure,
	title = {The {Architecture} of {Open} {Source} {Applications} ({Volume} 2): {The} {Glasgow} {Haskell} {Compiler}},
	url = {https://www.aosabook.org/en/ghc.html},
	urldate = {2019-04-05},
	file = {The Architecture of Open Source Applications (Volume 2)\: The Glasgow Haskell Compiler:/home/niklas/Zotero/storage/9589G3PQ/ghc.html:text/html}
}

@misc{haskell_code_generation,
	title = {generated code · {Wiki} · {Glasgow} {Haskell} {Compiler} / {GHC}},
	url = {https://gitlab.haskell.org/ghc/ghc/wikis/commentary/compiler/generated-code},
	abstract = {The Glorious Glasgow Haskell Compiler.},
	language = {en},
	urldate = {2019-04-05},
	journal = {GitLab},
	file = {Snapshot:/home/niklas/Zotero/storage/LR2ZESXR/generated-code.html:text/html}
}

@misc{haskell_language,
	title = {Haskell {Language}},
	url = {https://www.haskell.org/#step2},
	urldate = {2019-04-05},
	file = {Haskell Language:/home/niklas/Zotero/storage/EIYH95XQ/www.haskell.org.html:text/html}
}

@misc{haskell_whnf,
	title = {Weak head normal form - {HaskellWiki}},
	url = {https://wiki.haskell.org/Weak_head_normal_form},
	urldate = {2019-05-11},
	file = {Weak head normal form - HaskellWiki:/home/niklas/Zotero/storage/GJF6KSE8/Weak_head_normal_form.html:text/html}
}

@misc{pytest_benchmark,
	title = {py.test fixture for benchmarking code.},
	copyright = {BSD-2-Clause},
	url = {https://github.com/ionelmc/pytest-benchmark},
	urldate = {2019-05-11},
	author = {Mărieș, Ionel Cristian},
	month = may,
	year = {2019},
	note = {original-date: 2014-10-10T10:55:33Z}
}

@misc{openjdk_jmh,
	title = {{OpenJDK}: jmh},
	url = {https://openjdk.java.net/projects/code-tools/jmh/},
	urldate = {2019-05-11},
	file = {OpenJDK\: jmh:/home/niklas/Zotero/storage/FMNNTR2U/jmh.html:text/html}
}

@misc{reflexive_programmiersprachen,
	title = {Reflexive {Programmiersprachen}},
	url = {http://www.petendi.de/seminare/reflection/},
	urldate = {2019-05-12},
	file = {Reflexive Programmiersprachen:/home/niklas/Zotero/storage/X4T5PHFR/reflection.html:text/html}
}

@book{execution_systems,
	title = {Compilation {Techniques} for {Reconfigurable} {Architectures}},
	isbn = {978-0-387-09671-1},
	abstract = {The extreme ?exibility of recon?gurable architectures and their performance pot- tial have made them a vehicle of choice in a wide range of computing domains, from rapid circuit prototyping to high-performance computing. The increasing availab- ity of transistors on a die has allowed the emergence of recon?gurable architectures with a large number of computing resources and interconnection topologies. To - ploit the potential of these recon?gurable architectures, programmers are forced to map their applications, typically written in high-level imperative programming l- guages, such as C or MATLAB, to hardware-oriented languages such as VHDL or Verilog. In this process, they must assume the role of hardware designers and software programmers and navigate a maze of program transformations, mapping, and synthesis steps to produce ef?cient recon?gurable computing implementations. The richness and sophistication of any of these application mapping steps make the mapping of computations to these architectures an increasingly daunting process. It is thus widely believed that automatic compilation from high-level programming languages is the key to the success of recon?gurable computing. This book describes a wide range of code transformations and mapping te- niques for programs described in high-level programming languages, most - tably imperative languages, to recon?gurable architectures.},
	language = {en},
	publisher = {Springer Science \& Business Media},
	author = {Cardoso, João M. P. and Diniz, Pedro C.},
	month = apr,
	year = {2011},
	note = {Google-Books-ID: 4xwWNCiF9CgC},
	keywords = {Computers / Information Technology, Computers / Software Development \& Engineering / Systems Analysis \& Design, Computers / Systems Architecture / General, Technology \& Engineering / Electrical}
}

@book{advanced_compiler_design,
	title = {Advanced {Compiler} {Design} {Implementation}},
	isbn = {978-1-55860-320-2},
	abstract = {From the Foreword by Susan L. Graham: This book takes on the challenges of contemporary languages and architectures, and prepares the reader for the new compiling problems that will inevitably arise in the future. The definitive book on advanced compiler design This comprehensive, up-to-date work examines advanced issues in the design and implementation of compilers for modern processors. Written for professionals and graduate students, the book guides readers in designing and implementing efficient structures for highly optimizing compilers for real-world languages. Covering advanced issues in fundamental areas of compiler design, this book discusses a wide array of possible code optimizations, determining the relative importance of optimizations, and selecting the most effective methods of implementation. * Lays the foundation for understanding the major issues of advanced compiler design * Treats optimization in-depth * Uses four case studies of commercial compiling suites to illustrate different approaches to compiler structure, intermediate-code design, and optimization-these include Sun Microsystems's compiler for SPARC, IBM's for POWER and PowerPC, DEC's for Alpha, and Intel's for Pentium an related processors * Presents numerous clearly defined algorithms based on actual cases * Introduces Informal Compiler Algorithm Notation (ICAN), a language devised by the author to communicate algorithms effectively to people},
	language = {en},
	publisher = {Morgan Kaufmann},
	author = {Muchnick, Steven and Associates, Muchnick and},
	month = aug,
	year = {1997},
	note = {Google-Books-ID: Pq7pHwG1\_OkC},
	keywords = {Computers / Compilers, Computers / Software Development \& Engineering / General}
}