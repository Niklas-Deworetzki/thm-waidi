
@misc{ibm_microbenchmark,
	title = {Anatomy of a flawed microbenchmark},
	url = {http://www.ibm.com/developerworks/library/j-jtp02225/index.html},
	urldate = {2019-04-03},
	copyright = {© Copyright IBM Corporation 2005},
	abstract = {Software engineers are notoriously obsessed, sometimes excessively, with performance. While sometimes performance is the most important requirement in a software project, as it might be when developing protocol routing software for a high-speed switch, most of the time performance needs to be balanced against other requirements, such as functionality, reliability, maintainability, extensibility, time to market, and other business and engineering considerations. In this month's Java theory and practice, columnist Brian Goetz explores why it is so much harder to measure the performance of Java language constructs than it looks.},
	language = {en},
	year = {2005},
	file = {Snapshot:/home/niklas/Zotero/storage/TUYQQ69A/j-jtp02225.html:text/html}
}

@misc{oracle_benchmark_pitfalls,
	title = {Avoiding {Benchmarking} {Pitfalls} on the {JVM}},
	url = {https://www.oracle.com/technetwork/articles/java/architect-benchmarking-2266277.html},
	urldate = {2019-04-03},
	file = {Avoiding Benchmarking Pitfalls on the JVM:/home/niklas/Zotero/storage/DVPEGW3P/architect-benchmarking-2266277.html:text/html}
}

@misc{openjdk_hotspot,
	title = {{PerformanceTechniques} - {HotSpot} - {OpenJDK} {Wiki}},
	url = {https://wiki.openjdk.java.net/display/HotSpot/PerformanceTechniques},
	urldate = {2019-04-03},
	file = {PerformanceTechniques - HotSpot - OpenJDK Wiki:/home/niklas/Zotero/storage/SIJPC5DQ/PerformanceTechniques.html:text/html}
}

@misc{pytest_benchmark,
	title = {Usage — pytest-benchmark 3.2.2 documentation},
	url = {https://pytest-benchmark.readthedocs.io/en/stable/usage.html},
	urldate = {2019-04-04},
	file = {Usage — pytest-benchmark 3.2.2 documentation:/home/niklas/Zotero/storage/5RAGEYZ4/usage.html:text/html}
}

@misc{criterion,
	title = {A criterion tutorial},
	url = {http://www.serpentine.com/criterion/tutorial.html},
	urldate = {2019-04-04},
	file = {A criterion tutorial:/home/niklas/Zotero/storage/AMUZCT95/tutorial.html:text/html}
}

@misc{wikipedia_reflexion,
	title = {Reflexion ({Programmierung})},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://de.wikipedia.org/w/index.php?title=Reflexion_(Programmierung)&oldid=184375472},
	abstract = {Reflexion (englisch reflection) oder Introspektion bedeutet in der Programmierung, dass ein Programm seine eigene Struktur kennen und eventuell diese modifizieren kann.},
	language = {de},
	urldate = {2019-04-05},
	journal = {Wikipedia},
	year = {2019},
	note = {Page Version ID: 184375472},
	file = {Snapshot:/home/niklas/Zotero/storage/ZIIMMXFZ/index.html:text/html}
}

@misc{quora_pros_and_cons_of_compiled,
	title = {What are the pros and cons of a compiled programming language compared to a non-compiled one? - {Quora}},
	url = {https://www.quora.com/What-are-the-pros-and-cons-of-a-compiled-programming-language-compared-to-a-non-compiled-one#},
	urldate = {2019-04-05},
	file = {What are the pros and cons of a compiled programming language compared to a non-compiled one? - Quora:/home/niklas/Zotero/storage/B9PJ5WND/What-are-the-pros-and-cons-of-a-compiled-programming-language-compared-to-a-non-compiled-one.html:text/html}
}

@misc{wikipedia_optimizing_compiler,
	title = {Optimizing compiler},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=Optimizing_compiler&oldid=888564205},
	abstract = {In computing, an optimizing compiler is a compiler that tries to minimize or maximize some attributes of an executable computer program. The most common requirement is to minimize the time taken to execute a program; a less common one is to minimize the amount of memory occupied. The growth of portable computers has created a market for minimizing the power consumed by a program.
Compiler optimization is generally implemented using a sequence of optimizing transformations, algorithms which take a program and transform it to produce a semantically equivalent output program that uses fewer resources. It has been shown that some code optimization problems are NP-complete, or even undecidable. In practice, factors such as the programmer's willingness to wait for the compiler to complete its task place upper limits on the optimizations that a compiler implementor might provide. (Optimization is generally a very CPU- and memory-intensive process.) In the past, computer memory limitations were also a major factor in limiting which optimizations could be performed. Because of all these factors, optimization rarely produces "optimal" output in any sense, and in fact an "optimization" may impede performance in some cases; rather, they are heuristic methods for improving resource usage in typical programs.},
	language = {en},
	urldate = {2019-04-05},
	journal = {Wikipedia},
	year = {2019},
	note = {Page Version ID: 888564205},
	file = {Snapshot:/home/niklas/Zotero/storage/B75EMMSH/index.html:text/html}
}

@article{dwarampudi_comparative_study,
	title = {Comparative study of the {Pros} and {Cons} of {Programming} languages {Java}, {Scala}, {C}++, {Haskell}, {VB} .{NET}, {AspectJ}, {Perl}, {Ruby}, {PHP} \& {Scheme} - a {Team} 11 {COMP}6411-{S}10 {Term} {Report}},
	url = {http://arxiv.org/abs/1008.3431},
	abstract = {With the advent of numerous languages it is difficult to realize the edge of one language in a particular scope over another one. We are making an effort, realizing these few issues and comparing some main stream languages like Java, Scala, C++, Haskell, VB .NET, AspectJ, Perl, Ruby, PHP and Scheme keeping in mind some core issues in program development.},
	urldate = {2019-04-05},
	journal = {arXiv:1008.3431 [cs]},
	author = {Dwarampudi, Venkatreddy and Dhillon, Shahbaz Singh and Shah, Jivitesh and Sebastian, Nikhil Joseph and Kanigicharla, Nitin},
	year = {2010},
	note = {arXiv: 1008.3431},
	keywords = {Computer Science - Programming Languages, D.3},
	annote = {Comment: 28 pages, 2 tables},
	file = {arXiv\:1008.3431 PDF:/home/niklas/Zotero/storage/KQTRDHHM/Dwarampudi et al. - 2010 - Comparative study of the Pros and Cons of Programm.pdf:application/pdf;arXiv.org Snapshot:/home/niklas/Zotero/storage/3IBBMXBJ/1008.html:text/html}
}

@misc{list_of_languages,
	title = {List of programming languages by type},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=List_of_programming_languages_by_type&oldid=889388419},
	abstract = {This is a list of notable programming languages, grouped by type.
Since there is no overarching classification scheme for programming languages, in many cases, a language will be listed under multiple headings.},
	language = {en},
	urldate = {2019-04-05},
	journal = {Wikipedia},
	year = {2019},
	note = {Page Version ID: 889388419},
	file = {Snapshot:/home/niklas/Zotero/storage/G3ZMS2PY/index.html:text/html}
}

@misc{pros_and_cons_of_interpreted,
	title = {Pros {And} {Cons} {Of} {Interpreted} {Languages}},
	url = {https://stackoverflow.com/questions/1610539/pros-and-cons-of-interpreted-languages},
	urldate = {2019-04-05},
	journal = {Stack Overflow},
	file = {Snapshot:/home/niklas/Zotero/storage/I8FH3QF3/pros-and-cons-of-interpreted-languages.html:text/html}
}

@misc{wikipedia_runtime_system,
	title = {Runtime system},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=Runtime_system&oldid=887816064},
	abstract = {A runtime system, also called run-time system, runtime environment or run-time environment, primarily implements portions of an execution model.  This is not to be confused with the runtime lifecycle phase of a program, during which the runtime system is in operation.  Most languages have some form of runtime system that provides an environment in which programs run.  This environment may address a number of issues including the layout of application memory, how the program accesses variables, mechanisms for passing parameters between procedures, interfacing with the operating system, and otherwise.  The compiler makes assumptions depending on the specific runtime system to generate correct code.  Typically the runtime system will have some responsibility for setting up and managing the stack and heap, and may include features such as garbage collection, threads or other dynamic features built into the language.},
	language = {en},
	urldate = {2019-04-05},
	journal = {Wikipedia},
	year = {2019},
	note = {Page Version ID: 887816064},
	file = {Snapshot:/home/niklas/Zotero/storage/42LSRVU9/index.html:text/html}
}

@inproceedings{hudak_haskell_lazy_with_class,
	address = {San Diego, California},
	title = {A history of {Haskell}: being lazy with class},
	shorttitle = {A history of {Haskell}},
	url = {http://portal.acm.org/citation.cfm?doid=1238844.1238856},
	doi = {10.1145/1238844.1238856},
	abstract = {This paper describes the history of Haskell, including its genesis and principles, technical contributions, implementations and tools, and applications and impact.},
	language = {en},
	urldate = {2019-04-05},
	booktitle = {Proceedings of the third {ACM} {SIGPLAN} conference on {History} of programming languages  - {HOPL} {III}},
	publisher = {ACM Press},
	author = {Hudak, Paul and Hughes, John and Jones, Simon Peyton and Wadler, Philip},
	year = {2007},
	pages = {12--1--12--55},
	file = {Hudak et al. - 2007 - A history of Haskell being lazy with class.pdf:/home/niklas/Zotero/storage/CSMVLV6L/Hudak et al. - 2007 - A history of Haskell being lazy with class.pdf:application/pdf}
}

@misc{aosabook_ghc,
	title = {The {Architecture} of {Open} {Source} {Applications} ({Volume} 2): {The} {Glasgow} {Haskell} {Compiler}},
	url = {https://www.aosabook.org/en/ghc.html},
	urldate = {2019-04-05},
	file = {The Architecture of Open Source Applications (Volume 2)\: The Glasgow Haskell Compiler:/home/niklas/Zotero/storage/9589G3PQ/ghc.html:text/html}
}

@misc{ghc_code_generation,
	title = {generated code · {Wiki} · {Glasgow} {Haskell} {Compiler} / {GHC}},
	url = {https://gitlab.haskell.org/ghc/ghc/wikis/commentary/compiler/generated-code},
	abstract = {The Glorious Glasgow Haskell Compiler.},
	language = {en},
	urldate = {2019-04-05},
	journal = {GitLab},
	file = {Snapshot:/home/niklas/Zotero/storage/LR2ZESXR/generated-code.html:text/html}
}

@misc{haskell,
	title = {Haskell {Language}},
	url = {https://www.haskell.org/#step2},
	urldate = {2019-04-05},
	file = {Haskell Language:/home/niklas/Zotero/storage/EIYH95XQ/www.haskell.org.html:text/html}
}

@misc{wiki_haskell_whnf,
	title = {Weak head normal form - {HaskellWiki}},
	url = {https://wiki.haskell.org/Weak_head_normal_form},
	urldate = {2019-05-11},
	file = {Weak head normal form - HaskellWiki:/home/niklas/Zotero/storage/GJF6KSE8/Weak_head_normal_form.html:text/html}
}

@misc{github_pytest_benchmark,
	title = {py.test fixture for benchmarking code.},
	copyright = {BSD-2-Clause},
	url = {https://github.com/ionelmc/pytest-benchmark},
	urldate = {2019-05-11},
	author = {Mărieș, Ionel Cristian},
	month = may,
	year = {2019},
	note = {original-date: 2014-10-10T10:55:33Z}
}

@misc{openjdk_jmh,
	title = {{OpenJDK}: jmh},
	url = {https://openjdk.java.net/projects/code-tools/jmh/},
	urldate = {2019-05-11},
	file = {OpenJDK\: jmh:/home/niklas/Zotero/storage/FMNNTR2U/jmh.html:text/html}
}